# Assembly Language

An assembly (or assembler) language often abbreviated asm, is a low-level programming language for a computer, or other programmable device, in which there is a very strong (generally one-to-one) correspondence between the language and the architecture's machine code instructions. Each assembly language is specific to a particular computer architecture. In contrast, most high-level programming languages are generally portable across multiple architectures but require interpreting or compiling. Assembly language may also be called symbolic machine code.

```c
#include <stdio.h>

int main()
{
        printf("Hello World\n");
        return 0;
}
```

```bash
$ gcc -m32 -S hello.c 
$ cat hello.s 
        .section        __TEXT,__text,regular,pure_instructions
        .macosx_version_min 10, 10
        .globl  _main
        .align  4, 0x90
_main:                                  ## @main
## BB#0:
        pushl   %ebp
        movl    %esp, %ebp
        subl    $24, %esp
        calll   L0$pb
L0$pb:
        popl    %eax
        leal    L_.str-L0$pb(%eax), %eax
        movl    $0, -4(%ebp)
        movl    %eax, (%esp)
        calll   _printf
        xorl    %ecx, %ecx
        movl    %eax, -8(%ebp)          ## 4-byte Spill
        movl    %ecx, %eax
        addl    $24, %esp
        popl    %ebp
        retl

        .section        __TEXT,__cstring,cstring_literals
L_.str:                                 ## @.str
        .asciz  "Hello World\n"


.subsections_via_symbols
```

## x86 Architecture and Assembly Language

The set of instructions supported by the [x86 architecture](https://en.wikipedia.org/wiki/X86) is called the x86 instruction set and the corresponding assembly language is the x86 assembly language. It is a [CISC](https://en.wikipedia.org/wiki/Complex_instruction_set_computing) design based microprocessor architecture. It provides various instructions for data, function, stack, memory and other executive operations required by any modern operating system.

<center><img src='../../images/x86_arch.png'></img></center>

The x86 architecture can operate in any of the following mode:

* Real
* Protected
* Virtual 8086
* Long

Any x86 based CPU, old or new always initialises in the 16 bit *Real* mode in which the boot sector software is loaded and executed through the *BIOS* or *UEFI*. The boot loader software in turn locates and load the operating system which in turn setup appropriate operating mode for the CPU. Modern multi-tasking operating system requires the CPU to operate in *Protected* mode so that protected virtual memory, multi-tasking and other required CPU features are available. For CPUs that support the *Long* mode, a 64 bit capable operating system can enable this mode to use 64 bit addressing extension in the CPU.

<center><img src='../../images/x86_cpu_rings.png'></img></center>

The x86 architecture supports *privilege rings* so as to enable clear distinction between an executive software such as the OS kernel and a user application such as a browser launched by a user of the operating system. The processor supports specific mechanism such as [call gates][1] or special [system call](https://en.wikipedia.org/wiki/System_call) instructions for changing the privilege level of the CPU. The privilege levels help restrict access to privileged instructions such as those that can change the global state of the system to executive software only.

### Memory Management

<center><img src='../../images/x86_mm.png'></img></center>

x86 based CPU operating in *protected* mode uses [Virtual Memory](https://en.wikipedia.org/wiki/Virtual_memory). Any address used to reference the virtual memory is called a virtual address. The memory management unit of the CPU is responsible for translating a virtual address to linear or physical address based on information and support provided by the operating system kernel. The linear or physical address is used to reference any storage unit in the [RAM](https://en.wikipedia.org/wiki/Random-access_memory). This ensures virtual address space for each process in a running system and prevents intended or unintended tampering of each other's memory content by different processes. Operating Systems written for the x86 architecture uses a combination of [Segmentation](https://en.wikipedia.org/wiki/Memory_segmentation) and [Paging](https://en.wikipedia.org/wiki/Paging) for virtual memory management.

## Disassembler (IDA Pro)

A disassembler is a computer program that translates machine language into assembly languageâ€”the inverse operation to that of an assembler. A disassembler differs from a decompiler, which targets a high-level language rather than an assembly language. Disassembly, the output of a disassembler, is often formatted for human-readability rather than suitability for input to an assembler, making it principally a reverse-engineering tool.

[IDA Pro](https://www.hex-rays.com/products/ida/) is the most popular multi-platform multi-architecture disassembler used for professional reverse engineering and malware analysis.  The default disassembly of x86 PE File looks as below:

<center><img src='../../images/ida_main.png'></img></center>



# Reference

* <https://en.wikipedia.org/wiki/Assembly_language>
* <http://www.cs.virginia.edu/~evans/cs216/guides/x86.html>
* <https://www.nostarch.com/assembly2.htm>
* <http://ref.x86asm.net/>
* <https://en.wikipedia.org/wiki/X86_instruction_listings>
* <http://duartes.org/gustavo/blog/post/cpu-rings-privilege-and-protection>
* <http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html>
* <https://en.wikipedia.org/wiki/Disassembler>


[1]:https://en.wikipedia.org/wiki/Call_gate_(Intel)


