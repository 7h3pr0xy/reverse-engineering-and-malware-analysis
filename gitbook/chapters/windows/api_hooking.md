# API Hooking

API Hooking is the process of intercepting platform API calls by a process for instrumentation or analysis purpose. API Hooking techniques are usually platform and [ABI](https://en.wikipedia.org/wiki/Application_binary_interface) dependent. In Windows, there are multiple techniques for API Hooking, however [Microsoft Detours](https://www.microsoft.com/en-us/research/project/detours/) library is the officially supported mechanism for intercepting Windows API by Microsoft.

## Hooking Mechanism

<center><img src='../../images/api_hooking_detours.png'></img></center>

*Microsoft Detours* implement API Hooking by introducting a trampoline function that is called when the application calls the hooked function. The trampoline function is responsible for called the hook handler function and passing control to original API after the hook handler function has returned.

## Using Microsoft Detours for API Hooking

*Microsoft Detours* library provide C/C++ SDK for developing applications with API Hooking capability. The library can be used to develop *DLL* modules which when injected or loaded into a target process will intercept and trace required API.

### Initializing Hooks

```c
BOOL ProcessAttach(HMODULE hDll)
{
	SyelogOpen("HelloDetour", SYELOG_FACILITY_APPLICATION);

	DetourTransactionBegin();
	DetourUpdateThread(GetCurrentThread());

	DetourAttach(&(LPVOID&) Real_CreateFileW, (LPVOID) Detour_CreateFileW);

	Syelog(SYELOG_SEVERITY_NOTICE, "Detour Attached To: %d", GetCurrentProcessId());

	DetourTransactionCommit();
	return TRUE;
}
```

### Hook Handler

```c
HANDLE WINAPI Detour_CreateFileW(LPCWSTR a0,
								DWORD a1,
								DWORD a2,
								LPSECURITY_ATTRIBUTES a3,
							    DWORD a4,
							    DWORD a5,
							    HANDLE a6)
{
	CHAR	szPath[MAX_PATH  + 1];
	DWORD	dw;

	wcstombs_s((size_t*) &dw, szPath, MAX_PATH, a0, MAX_PATH);
	Syelog(SYELOG_SEVERITY_NOTICE, "CreateFileW: %s", szPath);
	return Real_CreateFileW(a0, a1, a2, a3, a4, a5, a6);
}
```

### Tracer Injection

In order to trace a target application, the hook DLL must be injected or loaded into the target process. This can be achieved by injecting a small *shellcode* in the target process that in turn called [LoadLibrary][1] API to load our tracer DLL in the target process. 

<center><img src='../../images/api_hooking_example.png'></img></center>

## Reference

* <http://www.codeproject.com/Articles/2082/API-hooking-revealed>

## Appendix

### Sample Application for API Hooking

```c
#include <windows.h>
#include <detours.h>
#include <syelog.h>

#include "DetourFunctions.h"


HANDLE WINAPI Detour_CreateFileW(LPCWSTR a0,
								DWORD a1,
								DWORD a2,
								LPSECURITY_ATTRIBUTES a3,
							    DWORD a4,
							    DWORD a5,
							    HANDLE a6)
{
	CHAR	szPath[MAX_PATH  + 1];
	DWORD	dw;

	wcstombs_s((size_t*) &dw, szPath, MAX_PATH, a0, MAX_PATH);
	Syelog(SYELOG_SEVERITY_NOTICE, "CreateFileW: %s", szPath);
	return Real_CreateFileW(a0, a1, a2, a3, a4, a5, a6);
}

BOOL ProcessAttach(HMODULE hDll)
{
	SyelogOpen("HelloDetour", SYELOG_FACILITY_APPLICATION);

	DetourTransactionBegin();
	DetourUpdateThread(GetCurrentThread());

	DetourAttach(&(LPVOID&) Real_CreateFileW, (LPVOID) Detour_CreateFileW);

	Syelog(SYELOG_SEVERITY_NOTICE, "Detour Attached To: %d", GetCurrentProcessId());

	DetourTransactionCommit();
	return TRUE;
}

BOOL ProcessDetach(HMODULE hDll)
{
	Syelog(SYELOG_SEVERITY_NOTICE, "Detour closing");
	SyelogClose(FALSE);

	return TRUE;
}

extern "C" {
	__declspec(dllexport) VOID __cdecl Init()
	{
		// Init Tasks
		// Called by Loader Shellcode (Injector)
	}
}

BOOL APIENTRY DllMain(HINSTANCE hModule, DWORD dwReason, PVOID lpReserved)
{
	switch(dwReason) {

	case DLL_PROCESS_ATTACH:
		return ProcessAttach(hModule);

	case DLL_PROCESS_DETACH:
		return ProcessDetach(hModule);

	case DLL_THREAD_ATTACH:
		break;
	case DLL_THREAD_DETACH:
		break;

	}

	return TRUE;
}
```

### Injector for API Hooking

```ruby
$:.unshift("C:\\Lib\\metasm")

require 'metasm'
require 'optparse'

$ASMCODE = 
	# Win32 PEB based API Resolver
	# Metasm seems to fail on jecxz so we compile using nasm and use the binary
	"\xe8\x56\x00\x00\x00\x53\x55\x56\x57\x8b\x6c\x24\x18\x8b\x45\x3c" +
	"\x8b\x54\x05\x78\x01\xea\x8b\x4a\x18\x8b\x5a\x20\x01\xeb\xe3\x32" +
	"\x49\x8b\x34\x8b\x01\xee\x31\xff\xfc\x31\xc0\xac\x38\xe0\x74\x07" +
	"\xc1\xcf\x0d\x01\xc7\xeb\xf2\x3b\x7c\x24\x14\x75\xe1\x8b\x5a\x24" +
	"\x01\xeb\x66\x8b\x0c\x4b\x8b\x5a\x1c\x01\xeb\x8b\x04\x8b\x01\xe8" +
	"\xeb\x02\x31\xc0\x5f\x5e\x5d\x5b\xc2\x08\x00\x31\xc9\x64\x8b\x71" +
	"\x30\x8b\x76\x0c\x8b\x76\x1c\x8b\x5e\x08\x8b\x7e\x20\x8b\x36\x66" +
	"\x39\x4f\x18\x75\xf2\x5e\x53\x68\x8e\x4e\x0e\xec\xff\xd6\x89\xc7" +
	"\x57\x56\x53\x89\xe5" +
	
	# %define LoadLibraryA     [ebp + 8]
	# %define LGetProcAddress  [ebp + 4]
	# %define KERNEL32 BASE    [ebp + 0]

	Metasm::Shellcode.assemble(Metasm::Ia32.new, %Q{
		jmp _end
		_start:
		
		pop ecx		; DLL Path in ECX
		
		; LoadLibraryA(DLL)
		push ecx
		call [ebp + 8]
		
		test eax, eax
		jz _exit
		
		; GetProcessAddress() and find Init()		
		push eax			; DLL Base
		push 0x95481bf4		; Hash of Init
		call [ebp + 4]
		
		test eax, eax
		jz _exit
		
		call eax			; Init() // FIXME: Crash Here if Init is not exported
		
		_exit:
		
		; Apparently ExitThread is not exported by kernel32 anymore
		; We need to call ntdll!RtlExitUserThread
		; Resolve Exit Thread
		;push [ebp]
		;push 0x60e0ceef		; Hash of Exit Thread
		;call [ebp + 4]
		
		; Call ExitThread
		;push 0x00
		;call eax
		
		call _getNtdll
		db 'ntdll.dll', 0x00
		
	_getNtdll:
		call [ebp + 8]		; LoadLibraryA('ntdll.dll')
		
		push eax
		push 0xff7f061a		; RtlExitUserThread
		call [ebp + 4]
		
		xor ebx, ebx
		push ebx
		call eax			; RtlExitUserThread(0)
		
		int 3
		
		_end:
		call _start
		; Path (ASCII) for DLL goes here

}).encode_string()
	
def process_inject_dll(process, path)
	puts "[+] Attempting to inject \"#{path}\" to pid: #{process.pid}"
	Metasm::WinOS.inject_run_shellcode(process, $ASMCODE + path.to_s + "\x00")
end
	
	
if __FILE__ == $0
	options = {}
	opts = OptionParser.new do |opts|
		opts.banner = "Usage: Injector.rb [options]"
		
		opts.on("-p", "--pid [PID]", "Inject to process identified by PID") do |pid|
			options[:pid] = pid.to_i
		end
		
		opts.on("-n", "--name [NAME]", "Inject to all processes matching name (eg. chrome.exe)") do |name|
			options[:name] = name.to_s
		end
		
		opts.on("-D", "--dll-path [PATH]", "Path of DLL to inject") do |dll|
			options[:dll] = dll.to_s
		end
		
		opts.on("-l", "--list", "List processes") do |v|
			options[:list_processes] = true
		end
	end
	
	opts.parse!
	
	if options[:list_processes]
		Metasm::WinOS.list_processes.each do |proc|
			puts "%d: %s" % [proc.pid, proc.modules.size > 0 ? proc.modules[0].path : "N/A"]
		end
		
		exit
	end
	
	if (options[:dll].nil?) or (options[:pid].nil? and options[:name].nil?)
		puts opts
		exit(1)
	end
	
	Metasm::WinOS.list_processes.each do |process|
		process_inject_dll(process, options[:dll]) if ((options[:pid]) and (process.pid == options[:pid].to_i)) or
														((options[:name]) and (!process.modules.empty?) and 
														(File.basename(process.modules[0].path).downcase == options[:name].downcase))
	end
end
```

[1]: https://msdn.microsoft.com/en-us/library/windows/desktop/ms684175(v=vs.85).aspx