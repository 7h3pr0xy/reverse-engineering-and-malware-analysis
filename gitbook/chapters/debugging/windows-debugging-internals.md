# Windows Debugging Internals

A debugger program essentially leverages Operating System provided programming interfaces to perform certain basic operation on a target process such as:

* Read or write process memory
* Change process context (registers)
* Receive and respond to debugging events
	* Process creation
	* Thread creation
	* Module Load
	* Exception
	* etc.
	
These fundamental operations supported by an Operating System through appropriate [API][1] allows higher level debugger programs to be written. Higher level abstractions and GUI for reading or writing memory, reading or writing register value, viewing disassembled instructions, setting breakpoints etc. can be implemented using these fundamental APIs.

## Breakpoint

A breakpoint is logically an address of an instruction or data in a debugged process which when set will trigger certain exception and pause or halt the process till it receives a *continue* event from the debugger process. This allows a debugger to pause a process at specific location and analyse process context and in-memory data.

## Sample Debugger using Windows API

### Debugger Process Privileges

```c
static
BOOL DbgEnablePrivilege()
{
    HANDLE              hToken;
    LUID                SeDebugNameValue;
    TOKEN_PRIVILEGES    TokenPrivileges;
	BOOL				bRet = FALSE;

	if(OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
    {
        if(LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &SeDebugNameValue))
        {
            TokenPrivileges.PrivilegeCount              = 1;
            TokenPrivileges.Privileges[0].Luid          = SeDebugNameValue;
            TokenPrivileges.Privileges[0].Attributes    = SE_PRIVILEGE_ENABLED;

            if(AdjustTokenPrivileges(hToken, FALSE, &TokenPrivileges, sizeof(TOKEN_PRIVILEGES), NULL, NULL))
            {
                CloseHandle(hToken);
				bRet = TRUE;
            }

        }
    }

	return bRet;
}
```

### Starting Target with Debugger Attached

```c
BOOL DebugRunProgA(CHAR *szPath, DEBUG_EVENT_HANDLERS *pHandlers)
{
	STARTUPINFOA si; 
	PROCESS_INFORMATION pi; 

	DbgEnablePrivilege();
	
	ZeroMemory(&si, sizeof(si)); 
	si.cb = sizeof(si); 
	ZeroMemory(&pi, sizeof(pi));

	if(!CreateProcessA(szPath, NULL, NULL, NULL, FALSE, DEBUG_PROCESS, NULL, NULL, &si, &pi)) {
		DMSG("CreateProcess failed!");
		return FALSE;
	}

	return DbgEventLoop(pHandlers);
}
```

### The Debugger Loop

```c
staticDWORD DbgHandleLoadDll(DEBUG_EVENT *e, DEBUG_EVENT_HANDLERS *pHandlers){	LOAD_DLL_DEBUG_INFO *li = &(e->u.LoadDll);	DMSG("DLL Loaded - Handle: 0x%08x BaseAddress: 0x%08x", li->hFile, li->lpBaseOfDll);	return 0;}staticBOOL DbgEventLoop(DEBUG_EVENT_HANDLERS *pHandlers){	DEBUG_EVENT		debug_event;	BOOL			bProcExit = FALSE;	while(!bProcExit) {		if(!WaitForDebugEvent(&debug_event, INFINITE))			break;		DMSG("Processing Debug Event: %d", debug_event.dwDebugEventCode);		switch(debug_event.dwDebugEventCode) {			case CREATE_PROCESS_DEBUG_EVENT:				break;			case EXIT_PROCESS_DEBUG_EVENT:				bProcExit = TRUE;				break;			case CREATE_THREAD_DEBUG_EVENT:				break;			case EXIT_THREAD_DEBUG_EVENT:				break;			case LOAD_DLL_DEBUG_EVENT:				DbgHandleLoadDll(&debug_event, pHandlers);				break;			case UNLOAD_DLL_DEBUG_EVENT:				break;			case EXCEPTION_DEBUG_EVENT:				break;			case OUTPUT_DEBUG_STRING_EVENT:				break;			default:				DMSG("Unhandled DebugEvent: 0x%08x", debug_event.dwDebugEventCode);		}		ContinueDebugEvent(debug_event.dwProcessId, 			debug_event.dwThreadId, DBG_CONTINUE);	}	return FALSE;}
```


[1]: https://msdn.microsoft.com/en-in/library/windows/desktop/ff818516(v=vs.85).aspx