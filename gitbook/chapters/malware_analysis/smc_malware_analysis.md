# SMC Malware Analysis

Self-modifying-code (SMC) is a common technique applied by advanced malware to evade static or signature based detection. These malware heavily obfuscate its original code under husks in order to make analysis difficult and time consuming process.

While custom tools or scripts may be required in order to analyse such malware, however the generic approach can be used against most samples:

* Identify decoder code
* Identify decoded code
* Extract decoded code at the time of execution

For our sample, we start by inspecting it in [CFF Explorer]():

<center><img src='/images/smc1.png'></img></center>

We then load the executable in IDA pro to inspect its functionality statically:

<center>
	<img src='/images/smc2.png'></img>
	<img src='/images/smc3.png'></img>
</center>

The executable appears to open a [HANDLE]() to *explorer.exe* process and if found, inject and execute some code into it. 

<center><img src='/images/smc4.png'></img></center>

We use [HiDump](https://github.com/abhisek/RandomCode/tree/master/Malware/HiDump) tool to dynamically extract the injected code from the sample:

<center><img src='/images/smc5.png'></img></center>

While the injected code must be native architecture specific code, there is no requirement for it to be a PE executable. The injected code can be any [PIC](https://en.wikipedia.org/wiki/Position-independent_code) that can run on the target architecture and OS platform. This is what we find when we load the extracted code into [IDA Pro]().

<center><img src='/images/smc6.png'></img></center>

After manual fixup, we can read the x86 assembly of the injected code:

<center><img src='/images/smc7.png'></img></center>

In order to dynamically analyse the injected code in a debugger, we develop a small script that can load and execute the injected code in memory while giving us control through a debugger:

```ruby
print "[*] Press [enter] to continue .."
$stdin.gets

code = File.binread(ARGV[0])
code = "\xcc" + code

process = ::Metasm::WinOS::Process.new(::Metasm::WinAPI.getcurrentprocessid)
::Metasm::WinOS.inject_run_shellcode(process, code)

puts "[*] Shellcode executed.. "
loop do
	puts "[*] Sleeping .."
	sleep(5)
end
```

The above Ruby script with execute the supplied code from file with a [int3](https://en.wikipedia.org/wiki/INT_(x86_instruction)) software interrupt instruction prepended. This will ensure that we get control in attached debugger immediately before the extracted code is executed. Once we are in debugger control, we can manually single-step or trace execution to identify the actual code.

We identify two types of encoders while stepping through the injected code in debugger:

<center><img src='/images/smc8.png'></img></center>

At some point, we identify that the decoded code has a valid PE header:

<center><img src='/images/smc9.png'></img></center>

We dump the data from memory where we identified valid PE header:

<center><img src='/images/smc10.png'></img></center>

Finally we open the dumped PE file which when analysed in [IDA Pro]() reveals the true form of the injected code:

<center><img src='/images/smc11.png'></img></center>