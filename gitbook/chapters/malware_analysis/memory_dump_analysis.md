# Memory Dump Analysis

Malware analysis tools largely depends on the underlying operating system especially the kernel to provide accurate information. If the integrity of the operating system kernel is compromised then results produced by various conventional malware analysis tools will be inaccurate.

Advanced malwares such as [Stuxnet](https://www.wired.com/2014/11/countdown-to-zero-day-stuxnet/) or [Duqu](https://securelist.com/blog/research/70641/the-duqu-2-0-persistence-module/) may attack the kernel of the infected OS which in turn may produce incorrect information to user-space tools including those used for malware analysis.

Memory dump analysis is a reliable approach towards malware analysis particularly in scenarios where the infected system cannot be trusted to produce appropriate information to user-space malware analysis tools.

## Live Memory Acquisition

Live memory acquisition is the process of obtaining the memory snapshot of a live system with minimum intervention to the running system. The objective is to acquire full contents of the physical memory including user data, system data and operating system data structures. This process is particularly useful during forensic analysis so as to preserve all evidences at the time of snapshot.

While there are multiple tools for live memory acquisition for Windows and Linux based Operating System, for the purpose of malware analysis, we can use VMware VMem files that contain the physical memory snapshot of a virtual machine at any point while the VM is running.

## Memory Dump Analysis with Volatility

[Volatility](https://github.com/volatilityfoundation/volatility) is one of the most popular free and open source tools for memory dump analysis. The tool supports multiple version of popular operating systems such as Windows, Linux, OSX. 

### Volatility Usage 

Identify the operating system of the image so as to use a suitable OS profile:

```bash
$ vol.py -f be2.vmem imageinfo
Volatility Foundation Volatility Framework 2.5
INFO    : volatility.debug    : Determining profile based on KDBG search...
          Suggested Profile(s) : WinXPSP2x86, WinXPSP3x86 (Instantiated with WinXPSP2x86)
                     AS Layer1 : IA32PagedMemoryPae (Kernel AS)
                     AS Layer2 : FileAddressSpace (/Volumes/SSD1/REMA/Memory Images/be2.vmem)
                      PAE type : PAE
                           DTB : 0x319000L
                          KDBG : 0x80544ce0L
          Number of Processors : 1
     Image Type (Service Pack) : 2
                KPCR for CPU 0 : 0xffdff000L
             KUSER_SHARED_DATA : 0xffdf0000L
           Image date and time : 2010-08-15 19:22:11 UTC+0000
     Image local date and time : 2010-08-15 15:22:11 -0400
```

Once a suitable profile has been identified, all subsequent commands must be run with the appropriate profile set.

#### Enumerate network connections

```bash
$ vol.py -f be2.vmem --profile=WinXPSP2x86 connections
Volatility Foundation Volatility Framework 2.5
Offset(V)  Local Address             Remote Address            Pid
---------- ------------------------- ------------------------- ---
```

```bash
$ vol.py -f be2.vmem --profile=WinXPSP2x86 connscan
Volatility Foundation Volatility Framework 2.5
Offset(P)  Local Address             Remote Address            Pid
---------- ------------------------- ------------------------- ---
0x02214988 172.16.176.143:1034       131.107.115.254:80        1260
0x06015ab0 172.16.176.143:1037       131.107.115.254:443       1260
```

#### Process Enumeration

```bash
$ vol.py -f be2.vmem --profile=WinXPSP2x86 pslist
Volatility Foundation Volatility Framework 2.5
Offset(V)  Name                    PID   PPID   Thds     Hnds   Sess  Wow64 Start                          Exit                          
---------- -------------------- ------ ------ ------ -------- ------ ------ ------------------------------ ------------------------------
0x810b1660 System                    4      0     59      179 ------      0                                                              
0xff2ab020 smss.exe                544      4      3       21 ------      0 2010-08-11 06:06:21 UTC+0000                                 
0xff1ecda0 csrss.exe               608    544     11      400      0      0 2010-08-11 06:06:23 UTC+0000                                 
0xff1ec978 winlogon.exe            632    544     22      519      0      0 2010-08-11 06:06:23 UTC+0000                                 
0xff247020 services.exe            676    632     16      268      0      0 2010-08-11 06:06:24 UTC+0000                                 
0xff255020 lsass.exe               688    632     22      348      0      0 2010-08-11 06:06:24 UTC+0000                                 
0xff218230 vmacthlp.exe            844    676      1       24      0      0 2010-08-11 06:06:24 UTC+0000                                 
0x80ff88d8 svchost.exe             856    676     19      321      0      0 2010-08-11 06:06:24 UTC+0000                                 
0xff217560 svchost.exe             936    676      9      261      0      0 2010-08-11 06:06:24 UTC+0000                                 
0x80fbf910 svchost.exe            1028    676     87     1394      0      0 2010-08-11 06:06:24 UTC+0000                                 
[...]
```

```bash
$ vol.py -f be2.vmem --profile=WinXPSP2x86 psscan
Volatility Foundation Volatility Framework 2.5
Offset(P)          Name                PID   PPID PDB        Time created                   Time exited                   
------------------ ---------------- ------ ------ ---------- ------------------------------ ------------------------------
0x000000000107e020 cmd.exe            1572    476 0x06cc0320 2010-08-15 19:21:27 UTC+0000   2010-08-15 19:21:27 UTC+0000  
0x00000000010c3da0 wuauclt.exe        1732   1028 0x06cc02c0 2010-08-11 06:07:44 UTC+0000                                 
0x00000000010f7588 wuauclt.exe         468   1028 0x06cc0180 2010-08-11 06:09:37 UTC+0000                                 
0x0000000001122910 svchost.exe        1028    676 0x06cc0120 2010-08-11 06:06:24 UTC+0000                                 
0x000000000115b8d8 svchost.exe         856    676 0x06cc00e0 2010-08-11 06:06:24 UTC+0000                    
[...]
```

```bash
$ vol.py -f be2.vmem --profile=WinXPSP2x86 pstree
[...]
 0xff3865d0:explorer.exe                             1724   1708     13    309 2010-08-11 06:09:29 UTC+0000
. 0xff374980:VMwareUser.exe                           452   1724      8    203 2010-08-11 06:09:32 UTC+0000
. 0xff3667e8:VMwareTray.exe                           432   1724      1     49 2010-08-11 06:09:31 UTC+0000
. 0xff1f6da0:1e0f1b9b697ab49                          476   1724      0 ------ 2010-08-15 19:21:25 UTC+0000
.. 0x80f1b020:cmd.exe                                1572    476      0 ------ 2010-08-15 19:21:27 UTC+0000
```

#### SSDT Enumeration

The [System Service Dispatcher Table](https://en.wikipedia.org/wiki/System_Service_Descriptor_Table) is a kernel data structure used to map system calls with their handler function. Usually all system call handlers are located in the core Windows kernel components such as *win32k.sys* or *ntoskrnl.exe* except if they are hooked by any malicious driver:

```bash
$ vol.py -f be2.vmem --profile=WinXPSP2x86 ssdt | grep -v win32k.sys | grep -v ntoskrnl.exe

Volatility Foundation Volatility Framework 2.5
[x86] Gathering all referenced SSDTs from KTHREADs...
Finding appropriate address space for tables...
SSDT[0] at ff3aab90 with 284 entries
  Entry 0x0041: 0xff0d2487 (NtDeleteValueKey) owned by 00004A2A
  Entry 0x0047: 0xff0d216b (NtEnumerateKey) owned by 00004A2A
  Entry 0x0049: 0xff0d2267 (NtEnumerateValueKey) owned by 00004A2A
  Entry 0x0077: 0xff0d20c3 (NtOpenKey) owned by 00004A2A
  Entry 0x007a: 0xff0d1e93 (NtOpenProcess) owned by 00004A2A
  Entry 0x0080: 0xff0d1f0b (NtOpenThread) owned by 00004A2A
  Entry 0x0089: 0xff0d2617 (NtProtectVirtualMemory) owned by 00004A2A
  Entry 0x00ad: 0xff0d1da0 (NtQuerySystemInformation) owned by 00004A2A
  Entry 0x00ba: 0xff0d256b (NtReadVirtualMemory) owned by 00004A2A
  Entry 0x00d5: 0xff0d2070 (NtSetContextThread) owned by 00004A2A
  Entry 0x00f7: 0xff0d2397 (NtSetValueKey) owned by 00004A2A
  Entry 0x00fe: 0xff0d201d (NtSuspendThread) owned by 00004A2A
  Entry 0x0102: 0xff0d1fca (NtTerminateThread) owned by 00004A2A
  Entry 0x0115: 0xff0d25c1 (NtWriteVirtualMemory) owned by 00004A2A
SSDT[0] at 80f162d0 with 284 entries
  Entry 0x0041: 0xff0d2487 (NtDeleteValueKey) owned by 00004A2A
  Entry 0x0047: 0xff0d216b (NtEnumerateKey) owned by 00004A2A
  Entry 0x0049: 0xff0d2267 (NtEnumerateValueKey) owned by 00004A2A
  Entry 0x0077: 0xff0d20c3 (NtOpenKey) owned by 00004A2A
  Entry 0x007a: 0xff0d1e93 (NtOpenProcess) owned by 00004A2A
  Entry 0x0080: 0xff0d1f0b (NtOpenThread) owned by 00004A2A
  Entry 0x0089: 0xff0d2617 (NtProtectVirtualMemory) owned by 00004A2A
  Entry 0x00ad: 0xff0d1da0 (NtQuerySystemInformation) owned by 00004A2A
  Entry 0x00ba: 0xff0d256b (NtReadVirtualMemory) owned by 00004A2A
  Entry 0x00d5: 0xff0d2070 (NtSetContextThread) owned by 00004A2A
  Entry 0x00f7: 0xff0d2397 (NtSetValueKey) owned by 00004A2A
  Entry 0x00fe: 0xff0d201d (NtSuspendThread) owned by 00004A2A
  Entry 0x0102: 0xff0d1fca (NtTerminateThread) owned by 00004A2A
  Entry 0x0115: 0xff0d25c1 (NtWriteVirtualMemory) owned by 00004A2A
SSDT[0] at 80501030 with 284 entries
SSDT[1] at bf997600 with 667 entries
```

List the base address of the possibly malicious kernel driver:

```bash
$ vol.py -f be2.vmem --profile=WinXPSP2x86 modules 
[...]
0x80fb16c0 wdmaud.sys           0xf3147000    0x15000 \SystemRoot\system32\drivers\wdmaud.sys
0xff381bd8 sysaudio.sys         0xf337d000     0xf000 \SystemRoot\system32\drivers\sysaudio.sys
0x80fae8b0 kmixer.sys           0xf2fe0000    0x2a000 \SystemRoot\system32\drivers\kmixer.sys
0xff2837e8 Fastfat.SYS          0xf2ef5000    0x23000 \SystemRoot\System32\Drivers\Fastfat.SYS
0xff375b08 00004A2A             0xff0d1000     0x8361 00004A2A
```

Extract the possibly malicious kernel driver:

```bash
$ vol.py -f be2.vmem --profile=WinXPSP2x86 moddump -b 0xff0d1000  -D /tmp/
Volatility Foundation Volatility Framework 2.5
Module Base Module Name          Result
----------- -------------------- ------
0x0ff0d1000 00004A2A             OK: driver.ff0d1000.sys
```

We then upload the extracted driver to [VirusTotal](http://www.virustotal.com) for a multi-AV scan:

<center><img src='../../images/be2_driver_vt.png'></img></center>

### Inference

In the above example, we start by looking at possibly malicious network connections. However in *connscan* the only network connection we find was made to 131.107.115.254. A *whois* lookup on this IP address reveals that the network range is owned by Microsoft which makes it an unlikely C&C controller IP address. 

Then we attempt to find possibly malicious process. Unable to find any malicious activity in user-mode, we continue our investigation for malicous code running as part of the kernel.

One of the most common kernel rootkit technique on Windows playform is [SSDT Hooking](http://resources.infosecinstitute.com/hooking-system-service-dispatch-table-ssdt/). In this technique, a malicious driver can hook important system functions by redirecting them at SSDT. We use the heuristic that all SSDT functions will by default point to core Windows kernel components such as win32k.sys or ntoskrnl.exe. Any SSDT function pointing outside core Windows kernel is possibly hooked. Using this heuristic we find a malicious driver which when extracted and submitted to VirusTotal confirms our assumption.


# References

<http://www.forensicswiki.org/wiki/Tools:Memory_Imaging>
<http://www.volatilityfoundation.org/>



