# File Identification and Analysis - II

## Description

A compressed PE executable is provided. The task involves decompressing the executable to find a hidden string inside the executable.

## Solution

Similar to previous compressed executable analysis, we start by identifying the packer/compressor used in the sample using [PEiD][1] tool.

<center><img src='/images/peid_sample2.png'></img></center>

The [PEiD][1] tools suggests that the sample is packed with [ASPack](http://www.aspack.com/). Unlike UPX, ASPack does not support decompression or unpacking of executable by itself. For this reason, we will have to manually unpack the executable. We will follow a _dynamic_ approach to unpack the sample and obtain the original executable. The approach can be summarized as:

* Identify loader code
* Identify Original Entry Point (OEP)
* Run sample in debugger while breaking in code that transitions to OEP
* Re-construct PE image from memory

Additionally we identify that the sample has two non-standard PE sections named *.aspack* and *.adata*. The *Entrypoint* in PE header points to *.aspack* section. This indicates that the *.aspack* section possibly contains the packer generated loader code that is responsibile for unpacking or decompressing original code before transferring control to it.

We start by disassembling the sample in [IDA Pro](https://www.hex-rays.com/products/ida/):

<center><img src='/images/aspack_ida1.png'></img></center>


The procedure prelog starts with a _pusha_ instruction that pushes the value of all registers to the stack. We manually analyse the loader code to identify a possible _popa_ instruction that should restore the register values from stack. This *may* indicate the epilogue of the loader code. We find a very interesting sequence of instructions near the expected epilogue:


<center><img src='/images/aspack_ida2.png'></img></center>


```asm
push 0
ret
```

The above two instructions, when execution, should result in a process crash with _EIP_ register set to 0 (NULL) which in most cases and definitely in case of our sample points to unmapped memory.

In order to identify what happens at runtime, we debug the sample in [x64Dbg](http://x64dbg.com/) with [OllyDumpEx](https://low-priority.appspot.com/ollydumpex/) plugin. We set a breakpoint at 0x0040F420 which is the address of *push 0* instruction. On breakpoint hit, it was found that the NULL value is overwritten with a address of valid instruction that will be executed when the *ret* instruction follows:

<center><img src='/images/aspack_dbg1.png'></img></center>

We manually single-step instructions till the newly discovered address is reached. At this point we reconstruct a new PE image from memory of our target process using 
[OllyDumpEx](https://low-priority.appspot.com/ollydumpex/) plugin:

<center><img src='/images/aspack_dbg2.png'></img></center>

While the newly created PE image may be recognized by IDA pro, it will probably not run correctly due to a broken import address table (IAT). We will need to rebuild the IAT so that the newly dumped executable can run correctly. This can be done using the [Scylla](https://github.com/NtQuery/Scylla) tool integrated with [x64Dbg](http://x64dbg.com/):

<center><img src='/images/aspack_scylla.png'></img></center>

At this point, we have fully recovered the original executable by identifying the OEP and reconstructing unpacked executable from the memory of the packed executable at runtime. This can be confirmed by loading the reconstructed executable in IDA pro:

<center><img src='/images/aspack_ida3.png'></img></center>


[1]: <http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/PEiD-updated.shtml>