# Portable Executable (PE) File Format

## Background

The Portable Executable (PE) format is a file format for executables, object code, DLLs, FON Font files, and others used in 32-bit and 64-bit versions of Windows operating systems. The PE format is a data structure that encapsulates the information necessary for the Windows OS loader to manage the wrapped executable code. This includes dynamic library references for linking, API export and import tables, resource management data and thread-local storage (TLS) data. On NT operating systems, the PE format is used for EXE, DLL, SYS (device driver), and other file types.

## Headers

<center>
	<img src='../../images/pe101.svg'></img><br/>
	<small><a href='https://github.com/corkami/pics/tree/master/pe101'>Source</a></small>
</center>

The [CFF Explorer](http://www.ntcore.com/exsuite.php) tool can be used to visualize PE Header and perform multiple operation including editing or dumping PE section to disk, scanning for packer signatures etc.

## Loading Process

The PE File Format defines a specification for code and data along with meta-information that is required by the PE loader to correctly load and prepare the executable in memory. The loading process as peformed by the PE Loader is as follows:

* Header Processing
* Section Mapping
* IAT Resolution
* Relocation
* Execute Entrypoint

## Developing a Custom PE Loader

A custom PE Loader is useful in various scenarios including:

* Dynamic Analysis
* Crypter / Loader Development
* Runtime Instrumentation

In order to develop a custom PE loader, the loader program must perform all the preparation and initialization tasks as performed by the original system PE Loader.

A proof of concept implementation of PE Loader is available at [Github](https://github.com/abhisek/Pe-Loader-Sample).

## Scripting PE File Format

The [Metasm](https://github.com/jjyg/metasm) library can be used for scripting the PE File Format in [Ruby](http://www.ruby-lang.org).

```ruby
$:.unshift("C:\\Lib\\metasm")
require 'metasm'

def dump_pe(arg)
	pe = Metasm::PE.decode_file(arg)
	
	puts "----- PE Headers ------"
	puts "Machine:                    " + pe.header.machine
	puts "Number of Sections:         " + pe.header.num_sect.to_s
	puts "Number of Symbols:          " + pe.header.num_sym.to_s
	puts "Characteristics:            " + pe.header.characteristics.inspect
	puts ""
	puts "Image Base:                 0x%08x" % [pe.optheader.image_base]
	puts "Image Size:                 0x%08x" % [pe.optheader.image_size]
	puts "Address of Entry Point:     0x%08x" % [pe.optheader.entrypoint]
	puts "Base of Code:               0x%08x" % [pe.optheader.base_of_code]
	puts "Base of Data:               0x%08x" % [pe.optheader.base_of_data]
	puts "File Alignment:             0x%08x" % [pe.optheader.file_align]
	puts "Section Alignment:          0x%08x" % [pe.optheader.sect_align]
	puts "-----------------------"
	puts ""
	puts "---- PE Sections --------"
	pe.sections.each do |section|
		puts "    Name:               " + section.name
		puts "    Raw Address:        0x%08x" % [section.rawaddr]
		puts "    Raw Size:           0x%08x" % [section.rawsize]
		puts "    Virtual Address:    0x%08x" % [section.virtaddr]
		puts "    Virtual Size:       0x%08x" % [section.virtsize]
		puts ""
	end
	puts "-------------------------"
	puts "------ PE Imports -------"
	pe.imports.each do |import|
		puts "  Library: " + import.libname
		import.imports.each do |imp|
			puts "		" + (imp.name || imp.target)
		end
		puts ""
	end unless pe.imports.nil?
	puts "-------------------------"
	puts "------ PE Exports -------"
	pe.export.exports.each do |exp|
		puts "	ORD: #{exp.ordinal} RAV: 0x%08x NAME: #{exp.name}" % [exp.target_rva]
	end unless pe.export.nil?
	puts "-------------------------"
end

if __FILE__ == $0
	if ARGV.size < 1
		puts "Usage: "
		puts "#{$0} [PE]"
		puts ""
		exit
	end
	
	dump_pe(ARGV[0].to_s)
end
```


## Reference

* <https://en.wikipedia.org/wiki/Portable_Executable>
* <https://github.com/corkami/pics/tree/master/pe101>